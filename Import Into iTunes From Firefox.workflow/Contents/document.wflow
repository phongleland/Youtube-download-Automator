<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
	<key>AMApplicationBuild</key>
	<string>246</string>
	<key>AMApplicationVersion</key>
	<string>2.1</string>
	<key>AMDocumentVersion</key>
	<string>2</string>
	<key>actions</key>
	<array>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>tell application "Firefox" to activatetell application "System Events"	keystroke "l" using {command down} -- Highlight the URL field.	keystroke "c" using {command down}end telldelay 0.5the clipboard</string>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>Disabled</key>
				<true/>
				<key>InputUUID</key>
				<string>17AFE0CA-A532-4357-8EF8-753F8CA4E280</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>07047309-D090-487E-8CCA-9135D5BAACB9</string>
				<key>UUID</key>
				<string>FB9A68D8-2E1D-426E-9BEA-7B747AE87558</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>302.000000:1495.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0.1</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>COMMAND_STRING</key>
					<dict/>
					<key>CheckedForUserDefaultShell</key>
					<dict/>
					<key>inputMethod</key>
					<dict/>
					<key>shell</key>
					<dict/>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.string</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run Shell Script.action</string>
				<key>ActionName</key>
				<string>Run Shell Script</string>
				<key>ActionParameters</key>
				<dict>
					<key>COMMAND_STRING</key>
					<string>import htmlentitydefs
import httplib
import locale
import math
import netrc
import os
import os.path
import re
import socket
import string
import sys
import time
import urllib
import urllib2

std_headers = {
	'User-Agent': 'Mozilla/5.0 (Windows; U; Windows NT 6.0; en-US; rv:1.9.1.2) Gecko/20090729 Firefox/3.5.2',
	'Accept-Charset': 'ISO-8859-1,utf-8;q=0.7,*;q=0.7',
	'Accept': 'text/xml,application/xml,application/xhtml+xml,text/html;q=0.9,text/plain;q=0.8,image/png,*/*;q=0.5',
	'Accept-Language': 'en-us,en;q=0.5',
}

simple_title_chars = string.ascii_letters.decode('ascii') + string.digits.decode('ascii')+'-'.decode('ascii')

def preferredencoding():
	"""Get preferred encoding.

	Returns the best encoding scheme for the system, based on
	locale.getpreferredencoding() and some further tweaks.
	"""
	def yield_preferredencoding():
		try:
			pref = locale.getpreferredencoding()
			u'TEST'.encode(pref)
		except:
			pref = 'UTF-8'
		while True:
			yield pref
	return yield_preferredencoding().next()

class DownloadError(Exception):
	"""Download Error exception.
	
	This exception may be thrown by FileDownloader objects if they are not
	configured to continue on errors. They will contain the appropriate
	error message.
	"""
	pass

class SameFileError(Exception):
	"""Same File exception.

	This exception will be thrown by FileDownloader objects if they detect
	multiple files would have to be downloaded to the same file on disk.
	"""
	pass

class PostProcessingError(Exception):
	"""Post Processing exception.

	This exception may be raised by PostProcessor's .run() method to
	indicate an error in the postprocessing task.
	"""
	pass

class UnavailableFormatError(Exception):
	"""Unavailable Format exception.

	This exception will be thrown when a video is requested
	in a format that is not available for that video.
	"""
	pass

class ContentTooShortError(Exception):
	"""Content Too Short exception.

	This exception may be raised by FileDownloader objects when a file they
	download is too small for what the server announced first, indicating
	the connection was probably interrupted.
	"""
	# Both in bytes
	downloaded = None
	expected = None

	def __init__(self, downloaded, expected):
		self.downloaded = downloaded
		self.expected = expected

class FileDownloader(object):
	"""File Downloader class.

	File downloader objects are the ones responsible of downloading the
	actual video file and writing it to disk if the user has requested
	it, among some other tasks. In most cases there should be one per
	program. As, given a video URL, the downloader doesn't know how to
	extract all the needed information, task that InfoExtractors do, it
	has to pass the URL to one of them.

	For this, file downloader objects have a method that allows
	InfoExtractors to be registered in a given order. When it is passed
	a URL, the file downloader handles it to the first InfoExtractor it
	finds that reports being able to handle it. The InfoExtractor extracts
	all the information about the video or videos the URL refers to, and
	asks the FileDownloader to process the video information, possibly
	downloading the video.

	File downloaders accept a lot of parameters. In order not to saturate
	the object constructor with arguments, it receives a dictionary of
	options instead. These options are available through the params
	attribute for the InfoExtractors to use. The FileDownloader also
	registers itself as the downloader in charge for the InfoExtractors
	that are added to it, so this is a "mutual registration".

	Available options:

	username:	Username for authentication purposes.
	password:	Password for authentication purposes.
	usenetrc:	Use netrc for authentication instead.
	quiet:		Do not print messages to stdout.
	forceurl:	Force printing final URL.
	forcetitle:	Force printing title.
	simulate:	Do not download the video files.
	format:		Video format code.
	outtmpl:	Template for output names.
	ignoreerrors:	Do not stop on download errors.
	ratelimit:	Download speed limit, in bytes/sec.
	nooverwrites:	Prevent overwriting files.
	continuedl:	Try to continue downloads if possible.
	"""

	params = None
	_ies = []
	_pps = []
	_download_retcode = None

	def __init__(self, params):
		"""Create a FileDownloader object with the given options."""
		self._ies = []
		self._pps = []
		self._download_retcode = 0
		self.params = params
	
	@staticmethod
	def pmkdir(filename):
		"""Create directory components in filename. Similar to Unix "mkdir -p"."""
		components = filename.split(os.sep)
		aggregate = [os.sep.join(components[0:x]) for x in xrange(1, len(components))]
		aggregate = ['%s%s' % (x, os.sep) for x in aggregate] # Finish names with separator
		for dir in aggregate:
			if not os.path.exists(dir):
				os.mkdir(dir)
	
	@staticmethod
	def format_bytes(bytes):
		if bytes is None:
			return 'N/A'
		if type(bytes) is str:
			bytes = float(bytes)
		if bytes == 0.0:
			exponent = 0
		else:
			exponent = long(math.log(bytes, 1024.0))
		suffix = 'bkMGTPEZY'[exponent]
		converted = float(bytes) / float(1024**exponent)
		return '%.2f%s' % (converted, suffix)

	@staticmethod
	def calc_percent(byte_counter, data_len):
		if data_len is None:
			return '---.-%'
		return '%6s' % ('%3.1f%%' % (float(byte_counter) / float(data_len) * 100.0))

	@staticmethod
	def calc_eta(start, now, total, current):
		if total is None:
			return '--:--'
		dif = now - start
		if current == 0 or dif &lt; 0.001: # One millisecond
			return '--:--'
		rate = float(current) / dif
		eta = long((float(total) - float(current)) / rate)
		(eta_mins, eta_secs) = divmod(eta, 60)
		if eta_mins &gt; 99:
			return '--:--'
		return '%02d:%02d' % (eta_mins, eta_secs)

	@staticmethod
	def calc_speed(start, now, bytes):
		dif = now - start
		if bytes == 0 or dif &lt; 0.001: # One millisecond
			return '%10s' % '---b/s'
		return '%10s' % ('%s/s' % FileDownloader.format_bytes(float(bytes) / dif))

	@staticmethod
	def best_block_size(elapsed_time, bytes):
		new_min = max(bytes / 2.0, 1.0)
		new_max = min(max(bytes * 2.0, 1.0), 4194304) # Do not surpass 4 MB
		if elapsed_time &lt; 0.001:
			return long(new_max)
		rate = bytes / elapsed_time
		if rate &gt; new_max:
			return long(new_max)
		if rate &lt; new_min:
			return long(new_min)
		return long(rate)

	@staticmethod
	def parse_bytes(bytestr):
		"""Parse a string indicating a byte quantity into a long integer."""
		matchobj = re.match(r'(?i)^(\d+(?:\.\d+)?)([kMGTPEZY]?)$', bytestr)
		if matchobj is None:
			return None
		number = float(matchobj.group(1))
		multiplier = 1024.0 ** 'bkmgtpezy'.index(matchobj.group(2).lower())
		return long(round(number * multiplier))

	@staticmethod
	def verify_url(url):
		"""Verify a URL is valid and data could be downloaded. Return real data URL."""
		request = urllib2.Request(url, None, std_headers)
		data = urllib2.urlopen(request)
		data.read(1)
		url = data.geturl()
		data.close()
		return url

	def add_info_extractor(self, ie):
		"""Add an InfoExtractor object to the end of the list."""
		self._ies.append(ie)
		ie.set_downloader(self)
	
	def add_post_processor(self, pp):
		"""Add a PostProcessor object to the end of the chain."""
		self._pps.append(pp)
		pp.set_downloader(self)
	
	def to_stdout(self, message, skip_eol=False):
		"""Print message to stdout if not in quiet mode."""
		if not self.params.get('quiet', False):
			print (u'%s%s' % (message, [u'\n', u''][skip_eol])).encode(preferredencoding()),
			sys.stdout.flush()
	
	def to_stderr(self, message):
		"""Print message to stderr."""
		print &gt;&gt;sys.stderr, message.encode(preferredencoding())
	
	def fixed_template(self):
		"""Checks if the output template is fixed."""
		return (re.search(ur'(?u)%\(.+?\)s', self.params['outtmpl']) is None)

	def trouble(self, message=None):
		"""Determine action to take when a download problem appears.

		Depending on if the downloader has been configured to ignore
		download errors or not, this method may throw an exception or
		not when errors are found, after printing the message.
		"""
		if message is not None:
			self.to_stderr(message)
		if not self.params.get('ignoreerrors', False):
			raise DownloadError(message)
		self._download_retcode = 1

	def slow_down(self, start_time, byte_counter):
		"""Sleep if the download speed is over the rate limit."""
		rate_limit = self.params.get('ratelimit', None)
		if rate_limit is None or byte_counter == 0:
			return
		now = time.time()
		elapsed = now - start_time
		if elapsed &lt;= 0.0:
			return
		speed = float(byte_counter) / elapsed
		if speed &gt; rate_limit:
			time.sleep((byte_counter - rate_limit * (now - start_time)) / rate_limit)

	def report_destination(self, filename):
		"""Report destination filename."""
		self.to_stdout(u'[download] Destination: %s' % filename)
	
	def report_progress(self, percent_str, data_len_str, speed_str, eta_str):
		"""Report download progress."""
		self.to_stdout(u'\r[download] %s of %s at %s ETA %s' %
				(percent_str, data_len_str, speed_str, eta_str), skip_eol=True)

	def report_resuming_byte(self, resume_len):
		"""Report attemtp to resume at given byte."""
		self.to_stdout(u'[download] Resuming download at byte %s' % resume_len)
	
	def report_file_already_downloaded(self, file_name):
		"""Report file has already been fully downloaded."""
		self.to_stdout(u'[download] %s has already been downloaded' % file_name)
	
	def report_unable_to_resume(self):
		"""Report it was impossible to resume download."""
		self.to_stdout(u'[download] Unable to resume')
	
	def report_finish(self):
		"""Report download finished."""
		self.to_stdout(u'')

	def process_info(self, info_dict):
		"""Process a single dictionary returned by an InfoExtractor."""
		# Do nothing else if in simulate mode
		if self.params.get('simulate', False):
			try:
				info_dict['url'] = self.verify_url(info_dict['url'].encode('utf-8')).decode('utf-8')
			except (OSError, IOError, urllib2.URLError, httplib.HTTPException, socket.error), err:
				raise UnavailableFormatError

			# Forced printings
			if self.params.get('forcetitle', False):
				print info_dict['title'].encode(preferredencoding())
			if self.params.get('forceurl', False):
				print info_dict['url'].encode(preferredencoding())

			return
			
		try:
			template_dict = dict(info_dict)
			template_dict['epoch'] = unicode(long(time.time()))
			filename = self.params['outtmpl'] % template_dict

		except (ValueError, KeyError), err:
			self.trouble('ERROR: invalid output template or system charset: %s' % str(err))
		if self.params.get('nooverwrites', False) and os.path.exists(filename):
			self.to_stderr(u'WARNING: file exists: %s; skipping' % filename)
			return

		try:
			self.pmkdir(filename)
		except (OSError, IOError), err:
			self.trouble('ERROR: unable to create directories: %s' % str(err))
			return

		try:
			success = self._do_download(filename, info_dict['url'].encode('utf-8'))
		except (OSError, IOError), err:
			raise UnavailableFormatError
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self.trouble('ERROR: unable to download video data: %s' % str(err))
			return
		except (ContentTooShortError, ), err:
			self.trouble('ERROR: content too short (expected %s bytes and served %s)' % (err.expected, err.downloaded))
			return

		if success:
			try:
				self.post_process(filename, info_dict)
			except (PostProcessingError), err:
				self.trouble('ERROR: postprocessing: %s' % str(err))
				return

	def download(self, url_list):
		"""Download a given list of URLs."""
		if len(url_list) &gt; 1 and self.fixed_template():
			raise SameFileError(self.params['outtmpl'])

		for url in url_list:
			suitable_found = False
			for ie in self._ies:
				# Go to next InfoExtractor if not suitable
				if not ie.suitable(url):
					continue

				# Suitable InfoExtractor found
				suitable_found = True

				# Extract information from URL and process it
				ie.extract(url)

				# Suitable InfoExtractor had been found; go to next URL
				break

			if not suitable_found:
				self.trouble('ERROR: no suitable InfoExtractor: %s' % url)

		return self._download_retcode

	def post_process(self, filename, ie_info):
		"""Run the postprocessing chain on the given file."""
		info = dict(ie_info)
		info['filepath'] = filename
		for pp in self._pps:
			info = pp.run(info)
			if info is None:
				break
	
	def _do_download(self, filename, url):
		video_filename=filename
		filename=os.getenv("HOME")+'/Movies/'+video_filename
		stream = None
		open_mode = 'ab'

		basic_request = urllib2.Request(url, None, std_headers)
		request = urllib2.Request(url, None, std_headers)

		# Attempt to resume download with "continuedl" option
		if os.path.isfile(filename):
			resume_len = os.path.getsize(filename)
		else:
			resume_len = 0
		if self.params.get('continuedl', False) and resume_len != 0:
			self.report_resuming_byte(resume_len)
			request.add_header('Range','bytes=%d-' % resume_len)

		# Establish connection
		try:
			data = urllib2.urlopen(request)
		except (urllib2.HTTPError, ), err:
			if err.code != 416: #  416 is 'Requested range not satisfiable'
				raise
			data = urllib2.urlopen(basic_request)
			content_length = data.info()['Content-Length']
			if content_length is not None and long(content_length) == resume_len:
				self.report_file_already_downloaded(filename)
				return True
			else:
				self.report_unable_to_resume()
				open_mode = 'wb'

		data_len = data.info().get('Content-length', None)
		data_len_str = self.format_bytes(data_len)
		byte_counter = 0
		block_size = 1024
		start = time.time()
		while True:
			# Download and write
			before = time.time()
			data_block = data.read(block_size)
			after = time.time()
			data_block_len = len(data_block)
			if data_block_len == 0:
				break
			byte_counter += data_block_len

			# Open file just in time
			if stream is None:
				try:
					stream = open(filename, open_mode)
					self.report_destination(filename)
				except (OSError, IOError), err:
					self.trouble('ERROR: unable to open for writing: %s' % str(err))
					return False
			stream.write(data_block)
			block_size = self.best_block_size(after - before, data_block_len)

			# Progress message
			percent_str = self.calc_percent(byte_counter, data_len)
			eta_str = self.calc_eta(start, time.time(), data_len, byte_counter)
			speed_str = self.calc_speed(start, time.time(), byte_counter)
			self.report_progress(percent_str, data_len_str, speed_str, eta_str)

			# Apply rate limit
			self.slow_down(start, byte_counter)

		self.report_finish()
		output_filename=filename+'.mp3'
		os.system('ffmpeg -i %s -ab 128 %s' % (filename, output_filename))
		if data_len is not None and str(byte_counter) != data_len:
			raise ContentTooShortError(byte_counter, long(data_len))
		return True

class InfoExtractor(object):
	"""Information Extractor class.

	Information extractors are the classes that, given a URL, extract
	information from the video (or videos) the URL refers to. This
	information includes the real video URL, the video title and simplified
	title, author and others. The information is stored in a dictionary
	which is then passed to the FileDownloader. The FileDownloader
	processes this information possibly downloading the video to the file
	system, among other possible outcomes. The dictionaries must include
	the following fields:

	id:		Video identifier.
	url:		Final video URL.
	uploader:	Nickname of the video uploader.
	title:		Literal title.
	stitle:		Simplified title.
	ext:		Video filename extension.

	Subclasses of this one should re-define the _real_initialize() and
	_real_extract() methods, as well as the suitable() static method.
	Probably, they should also be instantiated and added to the main
	downloader.
	"""

	_ready = False
	_downloader = None

	def __init__(self, downloader=None):
		"""Constructor. Receives an optional downloader."""
		self._ready = False
		self.set_downloader(downloader)

	@staticmethod
	def suitable(url):
		"""Receives a URL and returns True if suitable for this IE."""
		return False

	def initialize(self):
		"""Initializes an instance (authentication, etc)."""
		if not self._ready:
			self._real_initialize()
			self._ready = True

	def extract(self, url):
		"""Extracts URL information and returns it in list of dicts."""
		self.initialize()
		return self._real_extract(url)

	def set_downloader(self, downloader):
		"""Sets the downloader for this IE."""
		self._downloader = downloader
	
	def _real_initialize(self):
		"""Real initialization process. Redefine in subclasses."""
		pass

	def _real_extract(self, url):
		"""Real extraction process. Redefine in subclasses."""
		pass

class YoutubeIE(InfoExtractor):
	"""Information extractor for youtube.com."""

	_VALID_URL = r'^((?:http://)?(?:\w+\.)?youtube\.com/(?:(?:v/)|(?:(?:watch(?:\.php)?)?\?(?:.+&amp;)?v=)))?([0-9A-Za-z_-]+)(?(1).+)?$'
	_LANG_URL = r'http://uk.youtube.com/?hl=en&amp;persist_hl=1&amp;gl=US&amp;persist_gl=1&amp;opt_out_ackd=1'
	_LOGIN_URL = 'http://www.youtube.com/signup?next=/&amp;gl=US&amp;hl=en'
	_AGE_URL = 'http://www.youtube.com/verify_age?next_url=/&amp;gl=US&amp;hl=en'
	_NETRC_MACHINE = 'youtube'
	_available_formats = ['37', '22', '35', '18', '5', '17', '13', None] # listed in order of priority for -b flag
	_video_extensions = {
		'13': '3gp',
		'17': 'mp4',
		'18': 'mp4',
		'22': 'mp4',
		'37': 'mp4',
	}

	@staticmethod
	def suitable(url):
		return (re.match(YoutubeIE._VALID_URL, url) is not None)

	@staticmethod
	def htmlentity_transform(matchobj):
		"""Transforms an HTML entity to a Unicode character."""
		entity = matchobj.group(1)

		# Known non-numeric HTML entity
		if entity in htmlentitydefs.name2codepoint:
			return unichr(htmlentitydefs.name2codepoint[entity])

		# Unicode character
		mobj = re.match(ur'(?u)#(x?\d+)', entity)
		if mobj is not None:
			numstr = mobj.group(1)
			if numstr.startswith(u'x'):
				base = 16
				numstr = u'0%s' % numstr
			else:
				base = 10
			return unichr(long(numstr, base))

		# Unknown entity in name, return its literal representation
		return (u'&amp;%s;' % entity)

	def report_lang(self):
		"""Report attempt to set language."""
		self._downloader.to_stdout(u'[youtube] Setting language')

	def report_login(self):
		"""Report attempt to log in."""
		self._downloader.to_stdout(u'[youtube] Logging in')
	
	def report_age_confirmation(self):
		"""Report attempt to confirm age."""
		self._downloader.to_stdout(u'[youtube] Confirming age')
	
	def report_video_info_webpage_download(self, video_id):
		"""Report attempt to download video info webpage."""
		self._downloader.to_stdout(u'[youtube] %s: Downloading video info webpage' % video_id)
	
	def report_information_extraction(self, video_id):
		"""Report attempt to extract video information."""
		self._downloader.to_stdout(u'[youtube] %s: Extracting video information' % video_id)
	
	def report_unavailable_format(self, video_id, format):
		"""Report extracted video URL."""
		self._downloader.to_stdout(u'[youtube] %s: Format %s not available' % (video_id, format))
	
	def _real_initialize(self):
		if self._downloader is None:
			return

		username = None
		password = None
		downloader_params = self._downloader.params

		# Attempt to use provided username and password or .netrc data
		if downloader_params.get('username', None) is not None:
			username = downloader_params['username']
			password = downloader_params['password']
		elif downloader_params.get('usenetrc', False):
			try:
				info = netrc.netrc().authenticators(self._NETRC_MACHINE)
				if info is not None:
					username = info[0]
					password = info[2]
				else:
					raise netrc.NetrcParseError('No authenticators for %s' % self._NETRC_MACHINE)
			except (IOError, netrc.NetrcParseError), err:
				self._downloader.to_stderr(u'WARNING: parsing .netrc: %s' % str(err))
				return

		# Set language
		request = urllib2.Request(self._LANG_URL, None, std_headers)
		try:
			self.report_lang()
			urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.to_stderr(u'WARNING: unable to set language: %s' % str(err))
			return

		# No authentication to be performed
		if username is None:
			return

		# Log in
		login_form = {
				'current_form': 'loginForm',
				'next':		'/',
				'action_login':	'Log In',
				'username':	username,
				'password':	password,
				}
		request = urllib2.Request(self._LOGIN_URL, urllib.urlencode(login_form), std_headers)
		try:
			self.report_login()
			login_results = urllib2.urlopen(request).read()
			if re.search(r'(?i)&lt;form[^&gt;]* name="loginForm"', login_results) is not None:
				self._downloader.to_stderr(u'WARNING: unable to log in: bad username or password')
				return
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.to_stderr(u'WARNING: unable to log in: %s' % str(err))
			return
	
		# Confirm age
		age_form = {
				'next_url':		'/',
				'action_confirm':	'Confirm',
				}
		request = urllib2.Request(self._AGE_URL, urllib.urlencode(age_form), std_headers)
		try:
			self.report_age_confirmation()
			age_results = urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.trouble(u'ERROR: unable to confirm age: %s' % str(err))
			return

	def _real_extract(self, url):
		# Extract video id from URL
		mobj = re.match(self._VALID_URL, url)
		if mobj is None:
			self._downloader.trouble(u'ERROR: invalid URL: %s' % url)
			return
		video_id = mobj.group(2)

		# Downloader parameters
		best_quality = False
		format_param = None
		quality_index = 0
		if self._downloader is not None:
			params = self._downloader.params
			format_param = params.get('format', None)
			if format_param == '0':
				format_param = self._available_formats[quality_index]
				best_quality = True

		while True:
			# Extension
			video_extension = self._video_extensions.get(format_param, 'mp4')

			# Get video info
			video_info_url = 'http://www.youtube.com/get_video_info?&amp;video_id=%s&amp;el=detailpage&amp;ps=default&amp;eurl=&amp;gl=US&amp;hl=en' % video_id
			request = urllib2.Request(video_info_url, None, std_headers)
			try:
				self.report_video_info_webpage_download(video_id)
				video_info_webpage = urllib2.urlopen(request).read()
			except (urllib2.URLError, httplib.HTTPException, socket.error), err:
				self._downloader.trouble(u'ERROR: unable to download video info webpage: %s' % str(err))
				return
			self.report_information_extraction(video_id)

			# "t" param
			mobj = re.search(r'(?m)&amp;token=([^&amp;]+)(?:&amp;|$)', video_info_webpage)
			if mobj is None:
				# Attempt to see if YouTube has issued an error message
				mobj = re.search(r'(?m)&amp;reason=([^&amp;]+)(?:&amp;|$)', video_info_webpage)
				if mobj is None:
					self._downloader.trouble(u'ERROR: unable to extract "t" parameter for unknown reason')
					stream = open('reportme-ydl-%s.dat' % time.time(), 'wb')
					stream.write(video_info_webpage)
					stream.close()
				else:
					reason = urllib.unquote_plus(mobj.group(1))
					self._downloader.trouble(u'ERROR: YouTube said: %s' % reason.decode('utf-8'))
				return
			token = urllib.unquote(mobj.group(1))
			video_real_url = 'http://www.youtube.com/get_video?video_id=%s&amp;t=%s&amp;eurl=&amp;el=detailpage&amp;ps=default&amp;gl=US&amp;hl=en' % (video_id, token)
			if format_param is not None:
				video_real_url = '%s&amp;fmt=%s' % (video_real_url, format_param)

			# uploader
			mobj = re.search(r'(?m)&amp;author=([^&amp;]+)(?:&amp;|$)', video_info_webpage)
			if mobj is None:
				self._downloader.trouble(u'ERROR: unable to extract uploader nickname')
				return
			video_uploader = urllib.unquote(mobj.group(1))

			# title
			mobj = re.search(r'(?m)&amp;title=([^&amp;]*)(?:&amp;|$)', video_info_webpage)
			if mobj is None:
				self._downloader.trouble(u'ERROR: unable to extract video title')
				return
			video_title = urllib.unquote_plus(mobj.group(1))
			video_title = video_title.decode('utf-8')
			video_title = re.sub(ur'(?u)&amp;(.+?);', self.htmlentity_transform, video_title)
			video_title = video_title.replace(os.sep, u'%')
			

			# simplified title
			simple_title = re.sub(ur'(?u)([^%s]+)' % simple_title_chars, ur'_', video_title)
			simple_title = simple_title.strip(ur'_')

			try:
				# Process video information
				self._downloader.process_info({
					'id':		video_id.decode('utf-8'),
					'url':		video_real_url.decode('utf-8'),
					'uploader':	video_uploader.decode('utf-8'),
					'title':	video_title,
					'stitle':	simple_title,
					'ext':		video_extension.decode('utf-8'),
				})

				return

			except UnavailableFormatError, err:
				if best_quality:
					if quality_index == len(self._available_formats) - 1:
						# I don't ever expect this to happen
						self._downloader.trouble(u'ERROR: no known formats available for video')
						return
					else:
						self.report_unavailable_format(video_id, format_param)
						quality_index += 1
						format_param = self._available_formats[quality_index]
						continue
				else: 
					self._downloader.trouble('ERROR: format not available for video')
					return


class MetacafeIE(InfoExtractor):
	"""Information Extractor for metacafe.com."""

	_VALID_URL = r'(?:http://)?(?:www\.)?metacafe\.com/watch/([^/]+)/([^/]+)/.*'
	_DISCLAIMER = 'http://www.metacafe.com/family_filter/'
	_FILTER_POST = 'http://www.metacafe.com/f/index.php?inputType=filter&amp;controllerGroup=user'
	_youtube_ie = None

	def __init__(self, youtube_ie, downloader=None):
		InfoExtractor.__init__(self, downloader)
		self._youtube_ie = youtube_ie

	@staticmethod
	def suitable(url):
		return (re.match(MetacafeIE._VALID_URL, url) is not None)

	def report_disclaimer(self):
		"""Report disclaimer retrieval."""
		self._downloader.to_stdout(u'[metacafe] Retrieving disclaimer')

	def report_age_confirmation(self):
		"""Report attempt to confirm age."""
		self._downloader.to_stdout(u'[metacafe] Confirming age')
	
	def report_download_webpage(self, video_id):
		"""Report webpage download."""
		self._downloader.to_stdout(u'[metacafe] %s: Downloading webpage' % video_id)
	
	def report_extraction(self, video_id):
		"""Report information extraction."""
		self._downloader.to_stdout(u'[metacafe] %s: Extracting information' % video_id)

	def _real_initialize(self):
		# Retrieve disclaimer
		request = urllib2.Request(self._DISCLAIMER, None, std_headers)
		try:
			self.report_disclaimer()
			disclaimer = urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.trouble(u'ERROR: unable to retrieve disclaimer: %s' % str(err))
			return

		# Confirm age
		disclaimer_form = {
			'filters': '0',
			'submit': "Continue - I'm over 18",
			}
		request = urllib2.Request(self._FILTER_POST, urllib.urlencode(disclaimer_form), std_headers)
		try:
			self.report_age_confirmation()
			disclaimer = urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.trouble(u'ERROR: unable to confirm age: %s' % str(err))
			return
	
	def _real_extract(self, url):
		# Extract id and simplified title from URL
		mobj = re.match(self._VALID_URL, url)
		if mobj is None:
			self._downloader.trouble(u'ERROR: invalid URL: %s' % url)
			return

		video_id = mobj.group(1)

		# Check if video comes from YouTube
		mobj2 = re.match(r'^yt-(.*)$', video_id)
		if mobj2 is not None:
			self._youtube_ie.extract('http://www.youtube.com/watch?v=%s' % mobj2.group(1))
			return

		simple_title = mobj.group(2).decode('utf-8')
		video_extension = 'flv'

		# Retrieve video webpage to extract further information
		request = urllib2.Request('http://www.metacafe.com/watch/%s/' % video_id)
		try:
			self.report_download_webpage(video_id)
			webpage = urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.trouble(u'ERROR: unable retrieve video webpage: %s' % str(err))
			return

		# Extract URL, uploader and title from webpage
		self.report_extraction(video_id)
		mobj = re.search(r'(?m)&amp;mediaURL=([^&amp;]+)', webpage)
		if mobj is None:
			self._downloader.trouble(u'ERROR: unable to extract media URL')
			return
		mediaURL = urllib.unquote(mobj.group(1))

		#mobj = re.search(r'(?m)&amp;gdaKey=(.*?)&amp;', webpage)
		#if mobj is None:
		#	self._downloader.trouble(u'ERROR: unable to extract gdaKey')
		#	return
		#gdaKey = mobj.group(1)
		#
		#video_url = '%s?__gda__=%s' % (mediaURL, gdaKey)

		video_url = mediaURL

		mobj = re.search(r'(?im)&lt;title&gt;(.*) - Video&lt;/title&gt;', webpage)
		if mobj is None:
			self._downloader.trouble(u'ERROR: unable to extract title')
			return
		video_title = mobj.group(1).decode('utf-8')

		mobj = re.search(r'(?ms)By:\s*&lt;a .*?&gt;(.+?)&lt;', webpage)
		if mobj is None:
			self._downloader.trouble(u'ERROR: unable to extract uploader nickname')
			return
		video_uploader = mobj.group(1)

		try:
			# Process video information
			self._downloader.process_info({
				'id':		video_id.decode('utf-8'),
				'url':		video_url.decode('utf-8'),
				'uploader':	video_uploader.decode('utf-8'),
				'title':	video_title,
				'stitle':	simple_title,
				'ext':		video_extension.decode('utf-8'),
			})
		except UnavailableFormatError:
			self._downloader.trouble(u'ERROR: format not available for video')


class YoutubeSearchIE(InfoExtractor):
	"""Information Extractor for YouTube search queries."""
	_VALID_QUERY = r'ytsearch(\d+|all)?:[\s\S]+'
	_TEMPLATE_URL = 'http://www.youtube.com/results?search_query=%s&amp;page=%s&amp;gl=US&amp;hl=en'
	_VIDEO_INDICATOR = r'href="/watch\?v=.+?"'
	_MORE_PAGES_INDICATOR = r'(?m)&gt;\s*Next\s*&lt;/a&gt;'
	_youtube_ie = None
	_max_youtube_results = 1000

	def __init__(self, youtube_ie, downloader=None):
		InfoExtractor.__init__(self, downloader)
		self._youtube_ie = youtube_ie
	
	@staticmethod
	def suitable(url):
		return (re.match(YoutubeSearchIE._VALID_QUERY, url) is not None)

	def report_download_page(self, query, pagenum):
		"""Report attempt to download playlist page with given number."""
		self._downloader.to_stdout(u'[youtube] query "%s": Downloading page %s' % (query, pagenum))

	def _real_initialize(self):
		self._youtube_ie.initialize()
	
	def _real_extract(self, query):
		mobj = re.match(self._VALID_QUERY, query)
		if mobj is None:
			self._downloader.trouble(u'ERROR: invalid search query "%s"' % query)
			return

		prefix, query = query.split(':')
		prefix = prefix[8:]
		if prefix == '':
			self._download_n_results(query, 1)
			return
		elif prefix == 'all':
			self._download_n_results(query, self._max_youtube_results)
			return
		else:
			try:
				n = long(prefix)
				if n &lt;= 0:
					self._downloader.trouble(u'ERROR: invalid download number %s for query "%s"' % (n, query))
					return
				elif n &gt; self._max_youtube_results:
					self._downloader.to_stderr(u'WARNING: ytsearch returns max %i results (you requested %i)'  % (self._max_youtube_results, n))
					n = self._max_youtube_results
				self._download_n_results(query, n)
				return
			except ValueError: # parsing prefix as integer fails
				self._download_n_results(query, 1)
				return

	def _download_n_results(self, query, n):
		"""Downloads a specified number of results for a query"""

		video_ids = []
		already_seen = set()
		pagenum = 1

		while True:
			self.report_download_page(query, pagenum)
			result_url = self._TEMPLATE_URL % (urllib.quote_plus(query), pagenum)
			request = urllib2.Request(result_url, None, std_headers)
			try:
				page = urllib2.urlopen(request).read()
			except (urllib2.URLError, httplib.HTTPException, socket.error), err:
				self._downloader.trouble(u'ERROR: unable to download webpage: %s' % str(err))
				return

			# Extract video identifiers
			for mobj in re.finditer(self._VIDEO_INDICATOR, page):
				video_id = page[mobj.span()[0]:mobj.span()[1]].split('=')[2][:-1]
				if video_id not in already_seen:
					video_ids.append(video_id)
					already_seen.add(video_id)
					if len(video_ids) == n:
						# Specified n videos reached
						for id in video_ids:
							self._youtube_ie.extract('http://www.youtube.com/watch?v=%s' % id)
						return

			if re.search(self._MORE_PAGES_INDICATOR, page) is None:
				for id in video_ids:
					self._youtube_ie.extract('http://www.youtube.com/watch?v=%s' % id)
				return

			pagenum = pagenum + 1

class YoutubePlaylistIE(InfoExtractor):
	"""Information Extractor for YouTube playlists."""

	_VALID_URL = r'(?:http://)?(?:\w+\.)?youtube.com/(?:view_play_list|my_playlists)\?.*?p=([^&amp;]+).*'
	_TEMPLATE_URL = 'http://www.youtube.com/view_play_list?p=%s&amp;page=%s&amp;gl=US&amp;hl=en'
	_VIDEO_INDICATOR = r'/watch\?v=(.+?)&amp;'
	_MORE_PAGES_INDICATOR = r'/view_play_list?p=%s&amp;page=%s'
	_youtube_ie = None

	def __init__(self, youtube_ie, downloader=None):
		InfoExtractor.__init__(self, downloader)
		self._youtube_ie = youtube_ie
	
	@staticmethod
	def suitable(url):
		return (re.match(YoutubePlaylistIE._VALID_URL, url) is not None)

	def report_download_page(self, playlist_id, pagenum):
		"""Report attempt to download playlist page with given number."""
		self._downloader.to_stdout(u'[youtube] PL %s: Downloading page #%s' % (playlist_id, pagenum))

	def _real_initialize(self):
		self._youtube_ie.initialize()
	
	def _real_extract(self, url):
		# Extract playlist id
		mobj = re.match(self._VALID_URL, url)
		if mobj is None:
			self._downloader.trouble(u'ERROR: invalid url: %s' % url)
			return

		# Download playlist pages
		playlist_id = mobj.group(1)
		video_ids = []
		pagenum = 1

		while True:
			self.report_download_page(playlist_id, pagenum)
			request = urllib2.Request(self._TEMPLATE_URL % (playlist_id, pagenum), None, std_headers)
			try:
				page = urllib2.urlopen(request).read()
			except (urllib2.URLError, httplib.HTTPException, socket.error), err:
				self._downloader.trouble(u'ERROR: unable to download webpage: %s' % str(err))
				return

			# Extract video identifiers
			ids_in_page = []
			for mobj in re.finditer(self._VIDEO_INDICATOR, page):
				if mobj.group(1) not in ids_in_page:
					ids_in_page.append(mobj.group(1))
			video_ids.extend(ids_in_page)

			if (self._MORE_PAGES_INDICATOR % (playlist_id.upper(), pagenum + 1)) not in page:
				break
			pagenum = pagenum + 1

		for id in video_ids:
			self._youtube_ie.extract('http://www.youtube.com/watch?v=%s' % id)
		return

class YoutubeUserIE(InfoExtractor):
	"""Information Extractor for YouTube users."""

	_VALID_URL = r'(?:http://)?(?:\w+\.)?youtube.com/user/(.*)'
	_TEMPLATE_URL = 'http://gdata.youtube.com/feeds/api/users/%s'
	_VIDEO_INDICATOR = r'http://gdata.youtube.com/feeds/api/videos/(.*)'
	_youtube_ie = None

	def __init__(self, youtube_ie, downloader=None):
		InfoExtractor.__init__(self, downloader)
		self._youtube_ie = youtube_ie
	
	@staticmethod
	def suitable(url):
		return (re.match(YoutubeUserIE._VALID_URL, url) is not None)

	def report_download_page(self, username):
		"""Report attempt to download user page."""
		self._downloader.to_stdout(u'[youtube] USR %s: Downloading page ' % (username))

	def _real_initialize(self):
		self._youtube_ie.initialize()
	
	def _real_extract(self, url):
		# Extract username
		mobj = re.match(self._VALID_URL, url)
		if mobj is None:
			self._downloader.trouble(u'ERROR: invalid url: %s' % url)
			return

		# Download user page
		username = mobj.group(1)
		video_ids = []
		pagenum = 1

		self.report_download_page(username)
		request = urllib2.Request(self._TEMPLATE_URL % (username), None, std_headers)
		try:
			page = urllib2.urlopen(request).read()
		except (urllib2.URLError, httplib.HTTPException, socket.error), err:
			self._downloader.trouble(u'ERROR: unable to download webpage: %s' % str(err))
			return

		# Extract video identifiers
		ids_in_page = []

		for mobj in re.finditer(self._VIDEO_INDICATOR, page):
			print mobj.group(1)
			if mobj.group(1) not in ids_in_page:
				ids_in_page.append(mobj.group(1))
		video_ids.extend(ids_in_page)

		for id in video_ids:
			self._youtube_ie.extract('http://www.youtube.com/watch?v=%s' % id)
		return

class PostProcessor(object):
	"""Post Processor class.

	PostProcessor objects can be added to downloaders with their
	add_post_processor() method. When the downloader has finished a
	successful download, it will take its internal chain of PostProcessors
	and start calling the run() method on each one of them, first with
	an initial argument and then with the returned value of the previous
	PostProcessor.

	The chain will be stopped if one of them ever returns None or the end
	of the chain is reached.

	PostProcessor objects follow a "mutual registration" process similar
	to InfoExtractor objects.
	"""

	_downloader = None

	def __init__(self, downloader=None):
		self._downloader = downloader

	def set_downloader(self, downloader):
		"""Sets the downloader for this PP."""
		self._downloader = downloader
	
	def run(self, information):
		"""Run the PostProcessor.

		The "information" argument is a dictionary like the ones
		composed by InfoExtractors. The only difference is that this
		one has an extra field called "filepath" that points to the
		downloaded file.

		When this method returns None, the postprocessing chain is
		stopped. However, this method may return an information
		dictionary that will be passed to the next postprocessing
		object in the chain. It can be the one it received after
		changing some fields.

		In addition, this method may raise a PostProcessingError
		exception that will be taken into account by the downloader
		it was called from.
		"""
		return information # by default, do nothing
	
### MAIN PROGRAM ###
if __name__ == '__main__':
	try:
		# Modules needed only when running the main program
		import getpass
		import optparse

		# Function to update the program file with the latest version from bitbucket.org
		def update_self(downloader, filename):
			# Note: downloader only used for options
			if not os.access (filename, os.W_OK):
				sys.exit('ERROR: no write permissions on %s' % filename)

			downloader.to_stdout('Updating to latest stable version...')
			latest_url = 'http://bitbucket.org/rg3/youtube-dl/raw/tip/LATEST_VERSION'
			latest_version = urllib.urlopen(latest_url).read().strip()
			prog_url = 'http://bitbucket.org/rg3/youtube-dl/raw/%s/youtube-dl' % latest_version
			newcontent = urllib.urlopen(prog_url).read()
			stream = open(filename, 'w')
			stream.write(newcontent)
			stream.close()
			downloader.to_stdout('Updated to version %s' % latest_version)

		# General configuration
		urllib2.install_opener(urllib2.build_opener(urllib2.ProxyHandler()))
		urllib2.install_opener(urllib2.build_opener(urllib2.HTTPCookieProcessor()))
		socket.setdefaulttimeout(300) # 5 minutes should be enough (famous last words)

		# Parse command line
		parser = optparse.OptionParser(
			usage='Usage: %prog [options] url...',
			version='INTERNAL',
			conflict_handler='resolve',
		)

		parser.add_option('-h', '--help',
				action='help', help='print this help text and exit')
		parser.add_option('-v', '--version',
				action='version', help='print program version and exit')
		parser.add_option('-U', '--update',
				action='store_true', dest='update_self', help='update this program to latest stable version')
		parser.add_option('-i', '--ignore-errors',
				action='store_true', dest='ignoreerrors', help='continue on download errors', default=False)
		parser.add_option('-r', '--rate-limit',
				dest='ratelimit', metavar='L', help='download rate limit (e.g. 50k or 44.6m)')

		authentication = optparse.OptionGroup(parser, 'Authentication Options')
		authentication.add_option('-u', '--username',
				dest='username', metavar='UN', help='account username')
		authentication.add_option('-p', '--password',
				dest='password', metavar='PW', help='account password')
		authentication.add_option('-n', '--netrc',
				action='store_true', dest='usenetrc', help='use .netrc authentication data', default=False)
		parser.add_option_group(authentication)

		video_format = optparse.OptionGroup(parser, 'Video Format Options')
		video_format.add_option('-f', '--format',
				action='store', dest='format', metavar='FMT', help='video format code')
		video_format.add_option('-b', '--best-quality',
				action='store_const', dest='format', help='download the best quality video possible', const='0')
		video_format.add_option('-m', '--mobile-version',
				action='store_const', dest='format', help='alias for -f 17', const='17')
		video_format.add_option('-d', '--high-def',
				action='store_const', dest='format', help='alias for -f 22', const='22')
		parser.add_option_group(video_format)

		verbosity = optparse.OptionGroup(parser, 'Verbosity / Simulation Options')
		verbosity.add_option('-q', '--quiet',
				action='store_true', dest='quiet', help='activates quiet mode', default=False)
		verbosity.add_option('-s', '--simulate',
				action='store_true', dest='simulate', help='do not download video', default=False)
		verbosity.add_option('-g', '--get-url',
				action='store_true', dest='geturl', help='simulate, quiet but print URL', default=False)
		verbosity.add_option('-e', '--get-title',
				action='store_true', dest='gettitle', help='simulate, quiet but print title', default=False)
		parser.add_option_group(verbosity)

		filesystem = optparse.OptionGroup(parser, 'Filesystem Options')
		filesystem.add_option('-t', '--title',
				action='store_true', dest='usetitle', help='use title in file name', default=True)
		filesystem.add_option('-l', '--literal',
				action='store_true', dest='useliteral', help='use literal title in file name', default=False)
		filesystem.add_option('-o', '--output',
				dest='outtmpl', metavar='TPL', help='output filename template')
		filesystem.add_option('-a', '--batch-file',
				dest='batchfile', metavar='F', help='file containing URLs to download')
		filesystem.add_option('-w', '--no-overwrites',
				action='store_true', dest='nooverwrites', help='do not overwrite files', default=False)
		filesystem.add_option('-c', '--continue',
				action='store_true', dest='continue_dl', help='resume partially downloaded files', default=False)
		parser.add_option_group(filesystem)

		(opts, args) = parser.parse_args()
        
		# Batch file verification
		batchurls = []
		if opts.batchfile is not None:
			try:
				batchurls = open(opts.batchfile, 'r').readlines()
				batchurls = [x.strip() for x in batchurls]
				batchurls = [x for x in batchurls if len(x) &gt; 0]
			except IOError:
				sys.exit(u'ERROR: batch file could not be read')
		all_urls = batchurls + args

		# Conflicting, missing and erroneous options
		if opts.usenetrc and (opts.username is not None or opts.password is not None):
			parser.error(u'using .netrc conflicts with giving username/password')
		if opts.password is not None and opts.username is None:
			parser.error(u'account username missing')
		if opts.outtmpl is not None and (opts.useliteral or opts.usetitle):
			parser.error(u'using output template conflicts with using title or literal title')
		if opts.usetitle and opts.useliteral:
			parser.error(u'using title conflicts with using literal title')
		if opts.username is not None and opts.password is None:
			opts.password = getpass.getpass(u'Type account password and press return:')
		if opts.ratelimit is not None:
			numeric_limit = FileDownloader.parse_bytes(opts.ratelimit)
			if numeric_limit is None:
				parser.error(u'invalid rate limit specified')
			opts.ratelimit = numeric_limit

		# Information extractors
		youtube_ie = YoutubeIE()
		metacafe_ie = MetacafeIE(youtube_ie)
		youtube_pl_ie = YoutubePlaylistIE(youtube_ie)
		youtube_user_ie = YoutubeUserIE(youtube_ie)
		youtube_search_ie = YoutubeSearchIE(youtube_ie)

		# File downloader
		fd = FileDownloader({
			'usenetrc': opts.usenetrc,
			'username': opts.username,
			'password': opts.password,
			'quiet': (opts.quiet or opts.geturl or opts.gettitle),
			'forceurl': opts.geturl,
			'forcetitle': opts.gettitle,
			'simulate': (opts.simulate or opts.geturl or opts.gettitle),
			'format': opts.format,
			'outtmpl': ((opts.outtmpl is not None and opts.outtmpl.decode(preferredencoding()))
				or (opts.usetitle and u'Youtube-%(stitle)s.%(ext)s')
				or (opts.useliteral and u'Youtube-%(title)s.%(ext)s')
				or u'%(id)s.%(ext)s'),
			'ignoreerrors': opts.ignoreerrors,
			'ratelimit': opts.ratelimit,
			'nooverwrites': opts.nooverwrites,
			'continuedl': opts.continue_dl,
			})
		fd.add_info_extractor(youtube_search_ie)
		fd.add_info_extractor(youtube_pl_ie)
		fd.add_info_extractor(youtube_user_ie)
		fd.add_info_extractor(metacafe_ie)
		fd.add_info_extractor(youtube_ie)

		# Update version
		if opts.update_self:
			update_self(fd, sys.argv[0])

		# Maybe do nothing
		if len(all_urls) &lt; 1:
			if not opts.update_self:
				parser.error(u'you must provide at least one URL')
			else:
				sys.exit()
		retcode = fd.download(all_urls)
		sys.exit(retcode)

	except DownloadError:
		sys.exit(1)
	except SameFileError:
		sys.exit(u'ERROR: fixed output name but more than one file to download')
	except KeyboardInterrupt:
		sys.exit(u'\nERROR: Interrupted by user')</string>
					<key>CheckedForUserDefaultShell</key>
					<true/>
					<key>inputMethod</key>
					<integer>1</integer>
					<key>shell</key>
					<string>/usr/bin/python</string>
					<key>source</key>
					<string></string>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.RunShellScript</string>
				<key>CFBundleVersion</key>
				<string>2.0.1</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunShellScriptAction</string>
				<key>Disabled</key>
				<true/>
				<key>InputUUID</key>
				<string>8A405B2E-454E-49AF-9E7C-550B43EAB9EC</string>
				<key>Keywords</key>
				<array>
					<string>Shell</string>
					<string>Script</string>
					<string>Command</string>
					<string>Run</string>
					<string>Unix</string>
				</array>
				<key>OutputUUID</key>
				<string>DD36C9EA-D946-4A8E-ACF7-891420563E3B</string>
				<key>UUID</key>
				<string>7198C9AA-104F-46A7-BC42-9E1FF17F6B35</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>inputMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<false/>
						<key>name</key>
						<string>CheckedForUserDefaultShell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
					<key>3</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>COMMAND_STRING</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>3</string>
					</dict>
					<key>4</key>
					<dict>
						<key>default value</key>
						<string>/bin/sh</string>
						<key>name</key>
						<string>shell</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>4</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>302.000000:1453.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run Shell Script.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array/>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>pauseDuration</key>
					<dict/>
					<key>pauseUnit</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array/>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Pause.action</string>
				<key>ActionName</key>
				<string>Pause</string>
				<key>ActionParameters</key>
				<dict>
					<key>pauseDuration</key>
					<real>5</real>
					<key>pauseUnit</key>
					<integer>0</integer>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.Pause</string>
				<key>CFBundleVersion</key>
				<string>2.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<true/>
				<key>CanShowWhenRun</key>
				<false/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>PauseAction</string>
				<key>Disabled</key>
				<true/>
				<key>InputUUID</key>
				<string>1FEDDCA8-9F43-4644-A1A7-33F7DA229190</string>
				<key>Keywords</key>
				<array>
					<string>Time</string>
					<string>Wait</string>
				</array>
				<key>OutputUUID</key>
				<string>10A6004A-1A85-4263-B22E-186A3B8E29D8</string>
				<key>UUID</key>
				<string>39F12380-9568-4DB5-B5C4-AB2A06E68CFD</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>pauseUnit</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<integer>0</integer>
						<key>name</key>
						<string>pauseDuration</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<false/>
				<key>location</key>
				<string>302.000000:1411.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Pause.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<false/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.path</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>itemType</key>
					<dict/>
					<key>predicate</key>
					<dict/>
					<key>searchPath</key>
					<dict>
						<key>isPathPopUp</key>
						<true/>
						<key>variableUUIDsInMenu</key>
						<array/>
					</dict>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.cocoa.path</string>
					</array>
				</dict>
				<key>AMRequiredResources</key>
				<array/>
				<key>AMSelectedInputType</key>
				<string>com.apple.cocoa.path</string>
				<key>AMSelectedOutputType</key>
				<string>com.apple.cocoa.path</string>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Find Finder Items 2.action</string>
				<key>ActionName</key>
				<string>Find Finder Items</string>
				<key>ActionParameters</key>
				<dict>
					<key>itemType</key>
					<string>com.apple.cocoa.path</string>
					<key>predicate</key>
					<data>
					YnBsaXN0MDDUAQIDBAUGmZpYJHZlcnNpb25Y
					JG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGG
					oK8QJAcIDxUdJygqMjY7PEFFS1BXDVhcYWdo
					bXJ3fH2BhIWIiY2SlFUkbnVsbNMJCgsMDQ5f
					EA9OU1N1YnByZWRpY2F0ZXNfEBdOU0NvbXBv
					dW5kUHJlZGljYXRlVHlwZVYkY2xhc3OAAhAB
					gCPSCxARElpOUy5vYmplY3RzgCKiExSAA4AY
					1BYXCxgZGhscXxAQTlNMZWZ0RXhwcmVzc2lv
					bl8QEU5TUmlnaHRFeHByZXNzaW9uXxATTlNQ
					cmVkaWNhdGVPcGVyYXRvcoAEgA6AF4AU1R4f
					CyAhIiMkJSZfEBBOU0V4cHJlc3Npb25UeXBl
					Xk5TU2VsZWN0b3JOYW1lWU5TT3BlcmFuZFtO
					U0FyZ3VtZW50cxADgAWADYAGgAhcdmFsdWVG
					b3JLZXk60h4LDSmAB9IrLC0uWiRjbGFzc25h
					bWVYJGNsYXNzZXNfEBBOU1NlbGZFeHByZXNz
					aW9uoy8wMV8QEE5TU2VsZkV4cHJlc3Npb25c
					TlNFeHByZXNzaW9uWE5TT2JqZWN00gsQMzSA
					DKE1gAnTNx4LODk6WU5TS2V5UGF0aIAKEAqA
					C1tjcmVhdGVkRGF0ZdIrLD0+XxAcTlNLZXlQ
					YXRoU3BlY2lmaWVyRXhwcmVzc2lvbqM/QDFf
					EBxOU0tleVBhdGhTcGVjaWZpZXJFeHByZXNz
					aW9uXE5TRXhwcmVzc2lvbtIrLEJDXk5TTXV0
					YWJsZUFycmF5o0JEMVdOU0FycmF50issRkdf
					EBNOU0tleVBhdGhFeHByZXNzaW9upEhJSjFf
					EBNOU0tleVBhdGhFeHByZXNzaW9uXxAUTlNG
					dW5jdGlvbkV4cHJlc3Npb25cTlNFeHByZXNz
					aW9u0x5MC01OT18QD05TQ29uc3RhbnRWYWx1
					ZRAAgA+AE9MLURBSU1VXTlMua2V5c4ASoVSA
					EKFWgBFdcHJlZGljYXRlVHlwZdIrLFlaXxAT
					TlNNdXRhYmxlRGljdGlvbmFyeaNZWzFcTlNE
					aWN0aW9uYXJ50issXV5fEBlOU0NvbnN0YW50
					VmFsdWVFeHByZXNzaW9uo19gMV8QGU5TQ29u
					c3RhbnRWYWx1ZUV4cHJlc3Npb25cTlNFeHBy
					ZXNzaW9u1GIfYwtkZU1mXk5TT3BlcmF0b3JU
					eXBlWk5TTW9kaWZpZXIQC4AVgBZYaXNUb2Rh
					eTrSKyxpal8QGU5TQ3VzdG9tUHJlZGljYXRl
					T3BlcmF0b3Kja2wxXxAZTlNDdXN0b21QcmVk
					aWNhdGVPcGVyYXRvcl8QE05TUHJlZGljYXRl
					T3BlcmF0b3LSKyxub18QFU5TQ29tcGFyaXNv
					blByZWRpY2F0ZaNwcTFfEBVOU0NvbXBhcmlz
					b25QcmVkaWNhdGVbTlNQcmVkaWNhdGXUFhcL
					GHN0G3aAGYAegBeAINUeHwsgISJ4JCV7gBqA
					DYAGgBtcdmFsdWVGb3JLZXk60gsQM3+ADKGA
					gBzTNx4Lgjk6gB2AC11maWxlRXh0ZW5zaW9u
					0x5MC02GT4AfgBNTbXAz1GJjC4qLTYwiV05T
					RmxhZ3MQY4Ah0issjo9fEBVOU0luUHJlZGlj
					YXRlT3BlcmF0b3KjkJExXxAVTlNJblByZWRp
					Y2F0ZU9wZXJhdG9yXxATTlNQcmVkaWNhdGVP
					cGVyYXRvctIrLESTokQx0isslZZfEBNOU0Nv
					bXBvdW5kUHJlZGljYXRlo5eYMV8QE05TQ29t
					cG91bmRQcmVkaWNhdGVbTlNQcmVkaWNhdGVf
					EA9OU0tleWVkQXJjaGl2ZXLRm5xUcm9vdIAB
					AAgAEQAaACMALQAyADcAXgBkAGsAfQCXAJ4A
					oACiAKQAqQC0ALYAuQC7AL0AxgDZAO0BAwEF
					AQcBCQELARYBKQE4AUIBTgFQAVIBVAFWAVgB
					ZQFqAWwBcQF8AYUBmAGcAa8BvAHFAcoBzAHO
					AdAB1wHhAeMB5QHnAfMB+AIXAhsCOgJHAkwC
					WwJfAmcCbAKCAocCnQK0AsECyALaAtwC3gLg
					AucC7wLxAvMC9QL3AvkDBwMMAyIDJgMzAzgD
					VANYA3QDgQOKA5kDpAOmA6gDqgOzA7gD1APY
					A/QECgQPBCcEKwRDBE8EWARaBFwEXgRgBGsE
					bQRvBHEEcwSABIUEhwSJBIsEkgSUBJYEpASr
					BK0ErwSzBLwExATGBMgEzQTlBOkFAQUXBRwF
					HwUkBToFPgVUBWAFcgV1BXoAAAAAAAACAQAA
					AAAAAACdAAAAAAAAAAAAAAAAAAAFfA==
					</data>
					<key>searchPath</key>
					<string>~/Movies</string>
				</dict>
				<key>Application</key>
				<array>
					<string>Finder</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.Find_Finder_Items_2</string>
				<key>CFBundleVersion</key>
				<string>2.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryFilesAndFolders</string>
				</array>
				<key>Class Name</key>
				<string>Find_Finder_Items_2</string>
				<key>Disabled</key>
				<false/>
				<key>InputUUID</key>
				<string>31A8BBA3-33D5-4AB8-BCF5-5BCD86228299</string>
				<key>Keywords</key>
				<array/>
				<key>OutputUUID</key>
				<string>32465747-8A22-4F14-A389-D64410FFA125</string>
				<key>UUID</key>
				<string>576AF6D3-76C1-4C3B-9EC9-A025E3542D9B</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Finder</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>com.apple.cocoa.path</string>
						<key>name</key>
						<string>itemType</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<string></string>
						<key>name</key>
						<string>searchPath</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
					<key>2</key>
					<dict>
						<key>default value</key>
						<data>
						</data>
						<key>name</key>
						<string>predicate</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>2</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>302.000000:1369.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Find Finder Items 2.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>on run {input, parameters}		tell application "iTunes"		set newFile to input		add newFile	end tell	tell application "Finder"		delete input	end tellend run</string>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>Disabled</key>
				<false/>
				<key>InputUUID</key>
				<string>2C766597-B131-404E-83AF-B59FA1A10320</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>C797047A-82E3-4350-8CDB-99F7AB4BD715</string>
				<key>UUID</key>
				<string>A89923B0-BC3D-4A0A-8CC1-2F1D57055CC1</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>302.000000:964.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.itunes.track-object</string>
						<string>com.apple.itunes.playlist-object</string>
						<string>com.apple.itunes.source-object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>2.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>itemType</key>
					<dict/>
					<key>predicate</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.itunes.track-object</string>
						<string>com.apple.itunes.playlist-object</string>
						<string>com.apple.itunes.source-object</string>
					</array>
				</dict>
				<key>AMRequiredResources</key>
				<array/>
				<key>AMSelectedInputType</key>
				<string>com.apple.itunes.track-object</string>
				<key>AMSelectedOutputType</key>
				<string>com.apple.itunes.track-object</string>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Find iTunes Items 2.action</string>
				<key>ActionName</key>
				<string>Find iTunes Tracks</string>
				<key>ActionParameters</key>
				<dict>
					<key>itemType</key>
					<string>com.apple.itunes.track-object</string>
					<key>predicate</key>
					<data>
					YnBsaXN0MDDUAQIDBAUGbG1YJHZlcnNpb25Y
					JG9iamVjdHNZJGFyY2hpdmVyVCR0b3ASAAGG
					oK8QFgcIDxQcJicpMTU6O0BESk9QVVtgZWdV
					JG51bGzTCQoLDA0OXxAPTlNTdWJwcmVkaWNh
					dGVzXxAXTlNDb21wb3VuZFByZWRpY2F0ZVR5
					cGVWJGNsYXNzgAIQAYAV0gsQERJaTlMub2Jq
					ZWN0c4AUoROAA9QVFgsXGBkaG18QEE5TTGVm
					dEV4cHJlc3Npb25fEBFOU1JpZ2h0RXhwcmVz
					c2lvbl8QE05TUHJlZGljYXRlT3BlcmF0b3KA
					BIAOgBOAEdUdHgsfICEiIyQlXxAQTlNFeHBy
					ZXNzaW9uVHlwZV5OU1NlbGVjdG9yTmFtZVlO
					U09wZXJhbmRbTlNBcmd1bWVudHMQA4AFgA2A
					BoAIXHZhbHVlRm9yS2V5OtIdCw0ogAfSKiss
					LVokY2xhc3NuYW1lWCRjbGFzc2VzXxAQTlNT
					ZWxmRXhwcmVzc2lvbqMuLzBfEBBOU1NlbGZF
					eHByZXNzaW9uXE5TRXhwcmVzc2lvblhOU09i
					amVjdNILEDIzgAyhNIAJ0zYdCzc4OVlOU0tl
					eVBhdGiAChAKgAtUbmFtZdIqKzw9XxAcTlNL
					ZXlQYXRoU3BlY2lmaWVyRXhwcmVzc2lvbqM+
					PzBfEBxOU0tleVBhdGhTcGVjaWZpZXJFeHBy
					ZXNzaW9uXE5TRXhwcmVzc2lvbtIqK0FCXk5T
					TXV0YWJsZUFycmF5o0FDMFdOU0FycmF50ior
					RUZfEBNOU0tleVBhdGhFeHByZXNzaW9upEdI
					STBfEBNOU0tleVBhdGhFeHByZXNzaW9uXxAU
					TlNGdW5jdGlvbkV4cHJlc3Npb25cTlNFeHBy
					ZXNzaW9u0x1LC0xNTl8QD05TQ29uc3RhbnRW
					YWx1ZRAAgA+AEFhZb3V0dWJlLdIqK1FSXxAZ
					TlNDb25zdGFudFZhbHVlRXhwcmVzc2lvbqNT
					VDBfEBlOU0NvbnN0YW50VmFsdWVFeHByZXNz
					aW9uXE5TRXhwcmVzc2lvbtRWVwtYWUxaIV5O
					U09wZXJhdG9yVHlwZVpOU01vZGlmaWVyV05T
					RmxhZ3MQY4AS0iorXF1fEBVOU0luUHJlZGlj
					YXRlT3BlcmF0b3KjXl8wXxAVTlNJblByZWRp
					Y2F0ZU9wZXJhdG9yXxATTlNQcmVkaWNhdGVP
					cGVyYXRvctIqK2FiXxAVTlNDb21wYXJpc29u
					UHJlZGljYXRlo2NkMF8QFU5TQ29tcGFyaXNv
					blByZWRpY2F0ZVtOU1ByZWRpY2F0ZdIqK0Nm
					okMw0ioraGlfEBNOU0NvbXBvdW5kUHJlZGlj
					YXRlo2prMF8QE05TQ29tcG91bmRQcmVkaWNh
					dGVbTlNQcmVkaWNhdGVfEA9OU0tleWVkQXJj
					aGl2ZXLRbm9Ucm9vdIABAAgAEQAaACMALQAy
					ADcAUABWAF0AbwCJAJAAkgCUAJYAmwCmAKgA
					qgCsALUAyADcAPIA9AD2APgA+gEFARgBJwEx
					AT0BPwFBAUMBRQFHAVQBWQFbAWABawF0AYcB
					iwGeAasBtAG5AbsBvQG/AcYB0AHSAdQB1gHb
					AeAB/wIDAiICLwI0AkMCRwJPAlQCagJvAoUC
					nAKpArACwgLEAsYCyALRAtYC8gL2AxIDHwMo
					AzcDQgNKA0wDTgNTA2sDbwOHA50DogO6A74D
					1gPiA+cD6gPvBAUECQQfBCsEPQRABEUAAAAA
					AAACAQAAAAAAAABwAAAAAAAAAAAAAAAAAAAE
					Rw==
					</data>
				</dict>
				<key>Application</key>
				<array>
					<string>iTunes</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.Find_iTunes_Items_2</string>
				<key>CFBundleVersion</key>
				<string>2.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryMusic</string>
				</array>
				<key>Class Name</key>
				<string>Find_iTunes_Items_2</string>
				<key>Disabled</key>
				<false/>
				<key>InputUUID</key>
				<string>F641280B-6AAC-42ED-9286-84A452266503</string>
				<key>Keywords</key>
				<array/>
				<key>OutputUUID</key>
				<string>37AE9F9C-4535-4F01-BFB8-324868E15454</string>
				<key>UUID</key>
				<string>49FCC671-C150-4C7B-BC6F-91749C85378E</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>iTunes</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>com.apple.itunes.track-object</string>
						<key>name</key>
						<string>itemType</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
					<key>1</key>
					<dict>
						<key>default value</key>
						<data>
						</data>
						<key>name</key>
						<string>predicate</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>1</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>302.000000:651.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Find iTunes Items 2.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<false/>
					<key>Types</key>
					<array>
						<string>com.apple.itunes.track-object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>caseMethod</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.itunes.track-object</string>
					</array>
				</dict>
				<key>AMRequiredResources</key>
				<array>
					<dict>
						<key>Display Name</key>
						<string>iTunes</string>
						<key>Resource</key>
						<string>com.apple.iTunes</string>
						<key>Type</key>
						<string>application</string>
						<key>Version</key>
						<string>4.6</string>
					</dict>
				</array>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Change Case of Song Names.action</string>
				<key>ActionName</key>
				<string>Change Case of Song Names</string>
				<key>ActionParameters</key>
				<dict>
					<key>caseMethod</key>
					<integer>2</integer>
				</dict>
				<key>Application</key>
				<array>
					<string>iTunes</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.ChangeCaseofTrackNames</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<true/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryMusic</string>
				</array>
				<key>Class Name</key>
				<string>AMAppleScriptAction</string>
				<key>Disabled</key>
				<false/>
				<key>InputUUID</key>
				<string>D3E90AE5-AE86-42FB-87EC-098F80CCA53E</string>
				<key>Keywords</key>
				<array>
					<string>Change</string>
					<string>Name</string>
					<string>Song</string>
					<string>Music</string>
				</array>
				<key>OutputUUID</key>
				<string>BAF14456-8A4D-41E5-847A-767167B3BD65</string>
				<key>UUID</key>
				<string>041F3516-9939-42B7-87CA-DB63DF37372B</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>iTunes</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<integer>2</integer>
						<key>name</key>
						<string>caseMethod</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>302.000000:426.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Change Case of Song Names.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
		<dict>
			<key>action</key>
			<dict>
				<key>AMAccepts</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Optional</key>
					<true/>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>AMActionVersion</key>
				<string>1.0</string>
				<key>AMParameterProperties</key>
				<dict>
					<key>source</key>
					<dict/>
				</dict>
				<key>AMProvides</key>
				<dict>
					<key>Container</key>
					<string>List</string>
					<key>Types</key>
					<array>
						<string>com.apple.applescript.object</string>
					</array>
				</dict>
				<key>ActionBundlePath</key>
				<string>/System/Library/Automator/Run AppleScript.action</string>
				<key>ActionName</key>
				<string>Run AppleScript</string>
				<key>ActionParameters</key>
				<dict>
					<key>source</key>
					<string>on run {input, parameters}		tell application "iTunes"		set sel to input		set numTracks to (length of sel)		repeat with t from 1 to numTracks			set shufflable of item t of sel to true			if (video kind of item t of sel is equal to movie) then				set video kind of item t of sel to music video			end if			set filename to name of item t of sel			set arr to my splitText(".flv", filename)			set filename to item 1 of arr			set arr to my splitText(".mp4", filename)			set filename to item 1 of arr			set arr to my splitText("Youtube-", filename)			set filename to item 2 of arr			set filename to my searchReplace(filename, "_", " ")			tell contents of item t of sel				set arr to my splitText("-", filename)				tell contents of item t of sel					if ((length of arr) &gt; 1) then						set {artist} to {item 1 of arr}						set {name} to {item 2 of arr}					end if					if ((length of arr) &lt; 2) then						set {name} to {item 1 of arr}					end if				end tell			end tell		end repeat	end tellend runon searchReplace(thisText, searchTerm, replacement)	set AppleScript's text item delimiters to searchTerm	set thisText to thisText's text items	set AppleScript's text item delimiters to replacement	set thisText to "" &amp; thisText	set AppleScript's text item delimiters to {""}	return thisTextend searchReplaceon splitText(delimiter, someText)	set prevTIDs to AppleScript's text item delimiters	set AppleScript's text item delimiters to delimiter	set output to text items of someText	set AppleScript's text item delimiters to prevTIDs	return outputend splitText</string>
				</dict>
				<key>Application</key>
				<array>
					<string>Automator</string>
				</array>
				<key>BundleIdentifier</key>
				<string>com.apple.Automator.RunScript</string>
				<key>CFBundleVersion</key>
				<string>1.0</string>
				<key>CanShowSelectedItemsWhenRun</key>
				<false/>
				<key>CanShowWhenRun</key>
				<true/>
				<key>Category</key>
				<array>
					<string>AMCategoryUtilities</string>
				</array>
				<key>Class Name</key>
				<string>RunScriptAction</string>
				<key>Disabled</key>
				<false/>
				<key>InputUUID</key>
				<string>A1B3507A-69F2-4FEF-AF54-F6A13B76336A</string>
				<key>Keywords</key>
				<array>
					<string>Run</string>
				</array>
				<key>OutputUUID</key>
				<string>ECB1DCE1-62D7-4A1F-B2F4-A2204754A14E</string>
				<key>UUID</key>
				<string>DC9F98FA-E750-4FDD-9FA7-E32EB1889980</string>
				<key>UnlocalizedApplications</key>
				<array>
					<string>Automator</string>
				</array>
				<key>arguments</key>
				<dict>
					<key>0</key>
					<dict>
						<key>default value</key>
						<string>on run {input, parameters}
	
	(* Your script goes here *)
	
	return input
end run</string>
						<key>name</key>
						<string>source</string>
						<key>required</key>
						<string>0</string>
						<key>type</key>
						<string>0</string>
						<key>uuid</key>
						<string>0</string>
					</dict>
				</dict>
				<key>isViewVisible</key>
				<true/>
				<key>location</key>
				<string>302.000000:323.000000</string>
				<key>nibPath</key>
				<string>/System/Library/Automator/Run AppleScript.action/Contents/Resources/English.lproj/main.nib</string>
			</dict>
			<key>isViewVisible</key>
			<true/>
		</dict>
	</array>
	<key>connectors</key>
	<dict>
		<key>03B1E05E-8400-4E55-915B-26540BEA63E3</key>
		<dict>
			<key>from</key>
			<string>A89923B0-BC3D-4A0A-8CC1-2F1D57055CC1 - A89923B0-BC3D-4A0A-8CC1-2F1D57055CC1</string>
			<key>to</key>
			<string>49FCC671-C150-4C7B-BC6F-91749C85378E - 49FCC671-C150-4C7B-BC6F-91749C85378E</string>
		</dict>
		<key>53FE551B-3DF9-495F-A060-E9E67705FAFF</key>
		<dict>
			<key>from</key>
			<string>576AF6D3-76C1-4C3B-9EC9-A025E3542D9B - 576AF6D3-76C1-4C3B-9EC9-A025E3542D9B</string>
			<key>to</key>
			<string>A89923B0-BC3D-4A0A-8CC1-2F1D57055CC1 - A89923B0-BC3D-4A0A-8CC1-2F1D57055CC1</string>
		</dict>
		<key>59EB0730-BCF5-4D6C-8B14-C738E3F1AF95</key>
		<dict>
			<key>from</key>
			<string>041F3516-9939-42B7-87CA-DB63DF37372B - 041F3516-9939-42B7-87CA-DB63DF37372B</string>
			<key>to</key>
			<string>DC9F98FA-E750-4FDD-9FA7-E32EB1889980 - DC9F98FA-E750-4FDD-9FA7-E32EB1889980</string>
		</dict>
		<key>7100A4A5-CDD7-4CA2-A843-21C485BFBC9A</key>
		<dict>
			<key>from</key>
			<string>39F12380-9568-4DB5-B5C4-AB2A06E68CFD - 39F12380-9568-4DB5-B5C4-AB2A06E68CFD</string>
			<key>to</key>
			<string>576AF6D3-76C1-4C3B-9EC9-A025E3542D9B - 576AF6D3-76C1-4C3B-9EC9-A025E3542D9B</string>
		</dict>
		<key>9BFFE8FD-8609-478B-9438-084AF0E076BE</key>
		<dict>
			<key>from</key>
			<string>7198C9AA-104F-46A7-BC42-9E1FF17F6B35 - 7198C9AA-104F-46A7-BC42-9E1FF17F6B35</string>
			<key>to</key>
			<string>39F12380-9568-4DB5-B5C4-AB2A06E68CFD - 39F12380-9568-4DB5-B5C4-AB2A06E68CFD</string>
		</dict>
		<key>BC7FF7CD-317B-452F-AD6E-E448F5E700E7</key>
		<dict>
			<key>from</key>
			<string>FB9A68D8-2E1D-426E-9BEA-7B747AE87558 - FB9A68D8-2E1D-426E-9BEA-7B747AE87558</string>
			<key>to</key>
			<string>7198C9AA-104F-46A7-BC42-9E1FF17F6B35 - 7198C9AA-104F-46A7-BC42-9E1FF17F6B35</string>
		</dict>
		<key>CA282B58-84A0-49FE-B562-6AC57B6F5492</key>
		<dict>
			<key>from</key>
			<string>49FCC671-C150-4C7B-BC6F-91749C85378E - 49FCC671-C150-4C7B-BC6F-91749C85378E</string>
			<key>to</key>
			<string>041F3516-9939-42B7-87CA-DB63DF37372B - 041F3516-9939-42B7-87CA-DB63DF37372B</string>
		</dict>
	</dict>
	<key>state</key>
	<dict>
		<key>AMLogTabViewSelectedIndex</key>
		<integer>0</integer>
		<key>libraryState</key>
		<dict>
			<key>actionsMajorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 381.000000, 515.000000, NO</string>
					<string>0.000000, 516.000000, 381.000000, 239.000000, NO</string>
				</array>
			</dict>
			<key>actionsMinorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 163.000000, 515.000000, NO</string>
					<string>164.000000, 0.000000, 217.000000, 515.000000, NO</string>
				</array>
			</dict>
			<key>variablesMajorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 350.000000, 555.000000, NO</string>
					<string>0.000000, 556.000000, 350.000000, 148.000000, NO</string>
				</array>
			</dict>
			<key>variablesMinorSplitViewState</key>
			<dict>
				<key>expandedPosition</key>
				<real>0.0</real>
				<key>subviewState</key>
				<array>
					<string>0.000000, 0.000000, 163.000000, 555.000000, NO</string>
					<string>164.000000, 0.000000, 186.000000, 555.000000, NO</string>
				</array>
			</dict>
		</dict>
		<key>majorSplitViewState</key>
		<dict>
			<key>expandedPosition</key>
			<real>0.0</real>
			<key>subviewState</key>
			<array>
				<string>0.000000, 0.000000, 381.000000, 800.000000, NO</string>
				<string>382.000000, 0.000000, 619.000000, 800.000000, NO</string>
			</array>
		</dict>
		<key>minorSplitViewState</key>
		<dict>
			<key>expandedPosition</key>
			<real>0.0</real>
			<key>subviewState</key>
			<array>
				<string>0.000000, 0.000000, 619.000000, 609.000000, NO</string>
				<string>0.000000, 619.000000, 619.000000, 162.000000, NO</string>
			</array>
		</dict>
		<key>windowFrame</key>
		<string>{{201, 147}, {1000, 877}}</string>
		<key>workflowViewScrollPosition</key>
		<string>{{0, 0}, {604, 609}}</string>
	</dict>
	<key>workflowMetaData</key>
	<dict>
		<key>workflowTypeIdentifier</key>
		<string>com.apple.Automator.workflow</string>
	</dict>
</dict>
</plist>
